/**\n * Mock data generators and test utilities for SocialPulse testing\n */\n\nimport { TraderStats, Trade, Position, OrderRequest, HyperliquidConfig } from '../../src/services/hyperliquid';\n\n// Configuration for test environments\nexport const TEST_CONFIG: HyperliquidConfig = {\n  apiUrl: 'https://test-api.hyperliquid.xyz',\n  wsUrl: 'wss://test-api.hyperliquid.xyz/ws',\n  chainId: 31337, // Hardhat test network\n  privateKey: '0x' + '0'.repeat(64) // Test private key\n};\n\n// Mock trader addresses\nexport const MOCK_ADDRESSES = {\n  TRADER_1: '0x1234567890123456789012345678901234567890',\n  TRADER_2: '0x2345678901234567890123456789012345678901',\n  TRADER_3: '0x3456789012345678901234567890123456789012',\n  FOLLOWER: '0x9876543210987654321098765432109876543210',\n  SYSTEM: '0x0000000000000000000000000000000000000000'\n};\n\n// Base mock trader stats\nexport const createMockTrader = (overrides: Partial<TraderStats> = {}): TraderStats => {\n  const baseTrader: TraderStats = {\n    address: MOCK_ADDRESSES.TRADER_1,\n    pnl: 15420.50,\n    volume: 2500000.75,\n    winRate: 68.5,\n    sharpeRatio: 2.34,\n    maxDrawdown: 12.8,\n    totalTrades: 156,\n    avgHoldTime: 4.2,\n    roi: 24.8\n  };\n  \n  return { ...baseTrader, ...overrides };\n};\n\n// Generate multiple mock traders\nexport const createMockTraderList = (count: number): TraderStats[] => {\n  return Array.from({ length: count }, (_, index) => {\n    const performanceVariant = index % 4;\n    \n    switch (performanceVariant) {\n      case 0: // High performer\n        return createMockTrader({\n          address: `0x${(index + 1).toString().padStart(40, '0')}`,\n          pnl: 20000 + Math.random() * 30000,\n          volume: 5000000 + Math.random() * 10000000,\n          winRate: 70 + Math.random() * 25,\n          sharpeRatio: 2.5 + Math.random() * 2,\n          maxDrawdown: 5 + Math.random() * 15,\n          totalTrades: 200 + Math.random() * 300,\n          avgHoldTime: 3 + Math.random() * 8,\n          roi: 25 + Math.random() * 35\n        });\n        \n      case 1: // Medium performer\n        return createMockTrader({\n          address: `0x${(index + 1).toString().padStart(40, '0')}`,\n          pnl: 5000 + Math.random() * 15000,\n          volume: 1000000 + Math.random() * 4000000,\n          winRate: 55 + Math.random() * 20,\n          sharpeRatio: 1 + Math.random() * 1.5,\n          maxDrawdown: 15 + Math.random() * 20,\n          totalTrades: 100 + Math.random() * 200,\n          avgHoldTime: 2 + Math.random() * 6,\n          roi: 10 + Math.random() * 20\n        });\n        \n      case 2: // Low performer\n        return createMockTrader({\n          address: `0x${(index + 1).toString().padStart(40, '0')}`,\n          pnl: -5000 + Math.random() * 8000,\n          volume: 500000 + Math.random() * 1500000,\n          winRate: 35 + Math.random() * 25,\n          sharpeRatio: -0.5 + Math.random() * 1.2,\n          maxDrawdown: 25 + Math.random() * 30,\n          totalTrades: 50 + Math.random() * 150,\n          avgHoldTime: 1 + Math.random() * 4,\n          roi: -15 + Math.random() * 20\n        });\n        \n      default: // Very poor performer\n        return createMockTrader({\n          address: `0x${(index + 1).toString().padStart(40, '0')}`,\n          pnl: -20000 + Math.random() * 15000,\n          volume: 200000 + Math.random() * 800000,\n          winRate: 20 + Math.random() * 20,\n          sharpeRatio: -2 + Math.random() * 1.5,\n          maxDrawdown: 40 + Math.random() * 40,\n          totalTrades: 20 + Math.random() * 80,\n          avgHoldTime: 0.5 + Math.random() * 2,\n          roi: -40 + Math.random() * 25\n        });\n    }\n  });\n};\n\n// Mock trade data\nexport const createMockTrade = (overrides: Partial<Trade> = {}): Trade => {\n  const coins = ['BTC', 'ETH', 'SOL', 'AVAX', 'MATIC', 'DOT', 'LINK', 'UNI'];\n  const coin = coins[Math.floor(Math.random() * coins.length)];\n  const side = Math.random() > 0.5 ? 'buy' : 'sell';\n  \n  const basePrices = {\n    BTC: 47000,\n    ETH: 3000,\n    SOL: 100,\n    AVAX: 35,\n    MATIC: 0.8,\n    DOT: 25,\n    LINK: 18,\n    UNI: 12\n  };\n  \n  const basePrice = basePrices[coin as keyof typeof basePrices];\n  const priceVariation = 0.95 + Math.random() * 0.1; // Â±5% price variation\n  \n  const baseTrade: Trade = {\n    tid: `t${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n    coin,\n    side,\n    px: basePrice * priceVariation,\n    sz: Math.random() * 5 + 0.1, // 0.1 to 5.1\n    time: Date.now() - Math.random() * 86400000, // Within last 24h\n    fee: Math.random() * 0.1 + 0.01 // 0.01 to 0.11\n  };\n  \n  return { ...baseTrade, ...overrides };\n};\n\n// Generate trade history for a trader\nexport const createMockTradeHistory = (count: number, traderAddress: string): Trade[] => {\n  const trades: Trade[] = [];\n  const startTime = Date.now() - (30 * 24 * 60 * 60 * 1000); // 30 days ago\n  \n  for (let i = 0; i < count; i++) {\n    const trade = createMockTrade({\n      time: startTime + (i * (30 * 24 * 60 * 60 * 1000) / count)\n    });\n    trades.push(trade);\n  }\n  \n  return trades.sort((a, b) => a.time - b.time);\n};\n\n// Mock position data\nexport const createMockPosition = (overrides: Partial<Position> = {}): Position => {\n  const coins = ['BTC', 'ETH', 'SOL', 'AVAX'];\n  const coin = coins[Math.floor(Math.random() * coins.length)];\n  \n  const basePrices = {\n    BTC: 47000,\n    ETH: 3000,\n    SOL: 100,\n    AVAX: 35\n  };\n  \n  const entryPx = basePrices[coin as keyof typeof basePrices];\n  const szi = (Math.random() - 0.5) * 10; // -5 to 5 (negative = short)\n  const currentPx = entryPx * (0.95 + Math.random() * 0.1);\n  const unrealizedPnl = (currentPx - entryPx) * Math.abs(szi) * (szi > 0 ? 1 : -1);\n  \n  const basePosition: Position = {\n    coin,\n    szi,\n    entryPx,\n    unrealizedPnl,\n    returnOnEquity: unrealizedPnl / (entryPx * Math.abs(szi)),\n    leverage: 1 + Math.random() * 9, // 1x to 10x\n    maxLeverage: 50,\n    marginUsed: entryPx * Math.abs(szi) * 0.1 // 10% margin\n  };\n  \n  return { ...basePosition, ...overrides };\n};\n\n// Mock order request\nexport const createMockOrderRequest = (overrides: Partial<OrderRequest> = {}): OrderRequest => {\n  const coins = ['BTC', 'ETH', 'SOL'];\n  const coin = coins[Math.floor(Math.random() * coins.length)];\n  \n  const baseOrder: OrderRequest = {\n    coin,\n    isBuy: Math.random() > 0.5,\n    sz: Math.random() * 2 + 0.1,\n    limitPx: Math.random() > 0.5 ? undefined : 47000 + (Math.random() - 0.5) * 2000,\n    orderType: Math.random() > 0.7 ? 'market' : 'limit',\n    reduceOnly: Math.random() > 0.8,\n    postOnly: Math.random() > 0.9,\n    clientOrderId: `order-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`\n  };\n  \n  return { ...baseOrder, ...overrides };\n};\n\n// Mock API responses\nexport const mockApiResponses = {\n  leaderboard: (count: number = 10) => ({\n    traders: createMockTraderList(count),\n    total: count * 10,\n    hasMore: count < 100\n  }),\n  \n  accountInfo: (address: string) => ({\n    marginSummary: {\n      accountValue: (10000 + Math.random() * 50000).toString(),\n      totalNtlPos: (1000 + Math.random() * 5000).toString(),\n      availableBalance: (5000 + Math.random() * 20000).toString()\n    },\n    assetPositions: Array.from({ length: Math.floor(Math.random() * 5) }, () => createMockPosition())\n  }),\n  \n  tradeHistory: (address: string, count: number = 50) => \n    createMockTradeHistory(count, address),\n  \n  orderBook: (coin: string) => {\n    const basePrice = coin === 'BTC' ? 47000 : coin === 'ETH' ? 3000 : 100;\n    const bids = Array.from({ length: 20 }, (_, i) => [\n      basePrice - (i + 1) * 10,\n      Math.random() * 5 + 0.1\n    ]);\n    const asks = Array.from({ length: 20 }, (_, i) => [\n      basePrice + (i + 1) * 10,\n      Math.random() * 5 + 0.1\n    ]);\n    \n    return { coin, bids, asks };\n  },\n  \n  candles: (coin: string, interval: string) => {\n    const basePrice = coin === 'BTC' ? 47000 : coin === 'ETH' ? 3000 : 100;\n    const count = 100;\n    const candles = [];\n    \n    for (let i = 0; i < count; i++) {\n      const time = Date.now() - (count - i) * 3600000; // 1 hour intervals\n      const open = basePrice * (0.98 + Math.random() * 0.04);\n      const close = open * (0.98 + Math.random() * 0.04);\n      const high = Math.max(open, close) * (1 + Math.random() * 0.02);\n      const low = Math.min(open, close) * (1 - Math.random() * 0.02);\n      const volume = Math.random() * 1000 + 100;\n      \n      candles.push({ time, open, high, low, close, volume });\n    }\n    \n    return candles;\n  },\n  \n  orderResponse: (success: boolean = true) => ({\n    status: success ? 'ok' : 'error',\n    response: success ? {\n      type: 'order',\n      data: {\n        statuses: [{\n          filled: Math.random(),\n          pending: Math.random() * 0.5,\n          cancelled: 0\n        }]\n      }\n    } : {\n      error: 'Order failed',\n      code: 'INSUFFICIENT_BALANCE'\n    }\n  })\n};\n\n// WebSocket mock data\nexport const mockWebSocketData = {\n  tradeUpdate: (traderAddress: string) => ({\n    type: 'trade',\n    user: traderAddress,\n    data: createMockTrade(),\n    timestamp: Date.now()\n  }),\n  \n  orderBookUpdate: (coin: string) => ({\n    type: 'l2Book',\n    coin,\n    data: mockApiResponses.orderBook(coin),\n    timestamp: Date.now()\n  }),\n  \n  userEvent: (userAddress: string, eventType: string) => ({\n    type: 'userEvent',\n    user: userAddress,\n    eventType,\n    data: {\n      orderId: `order-${Date.now()}`,\n      status: Math.random() > 0.5 ? 'filled' : 'cancelled'\n    },\n    timestamp: Date.now()\n  })\n};\n\n// Test data validation helpers\nexport const validateTraderStats = (trader: TraderStats): boolean => {\n  return (\n    typeof trader.address === 'string' &&\n    trader.address.length === 42 &&\n    trader.address.startsWith('0x') &&\n    typeof trader.pnl === 'number' &&\n    typeof trader.volume === 'number' &&\n    typeof trader.winRate === 'number' &&\n    trader.winRate >= 0 && trader.winRate <= 100 &&\n    typeof trader.sharpeRatio === 'number' &&\n    typeof trader.maxDrawdown === 'number' &&\n    trader.maxDrawdown >= 0 &&\n    typeof trader.totalTrades === 'number' &&\n    trader.totalTrades >= 0 &&\n    typeof trader.avgHoldTime === 'number' &&\n    trader.avgHoldTime >= 0 &&\n    typeof trader.roi === 'number'\n  );\n};\n\nexport const validateTrade = (trade: Trade): boolean => {\n  return (\n    typeof trade.tid === 'string' &&\n    typeof trade.coin === 'string' &&\n    ['buy', 'sell'].includes(trade.side) &&\n    typeof trade.px === 'number' &&\n    trade.px > 0 &&\n    typeof trade.sz === 'number' &&\n    trade.sz > 0 &&\n    typeof trade.time === 'number' &&\n    trade.time > 0 &&\n    typeof trade.fee === 'number' &&\n    trade.fee >= 0\n  );\n};\n\n// Performance testing data\nexport const createLargeDataset = (size: 'small' | 'medium' | 'large' | 'xl') => {\n  const sizes = {\n    small: { traders: 50, trades: 100 },\n    medium: { traders: 200, trades: 500 },\n    large: { traders: 1000, trades: 2000 },\n    xl: { traders: 5000, trades: 10000 }\n  };\n  \n  const config = sizes[size];\n  \n  return {\n    traders: createMockTraderList(config.traders),\n    trades: Array.from({ length: config.trades }, () => createMockTrade()),\n    positions: Array.from({ length: config.traders * 3 }, () => createMockPosition())\n  };\n};\n\n// Error simulation helpers\nexport const simulateApiError = (type: 'network' | 'server' | 'auth' | 'rate-limit') => {\n  const errors = {\n    network: new Error('Network Error: Failed to fetch'),\n    server: {\n      response: {\n        status: 500,\n        data: { error: 'Internal Server Error' }\n      }\n    },\n    auth: {\n      response: {\n        status: 401,\n        data: { error: 'Unauthorized' }\n      }\n    },\n    'rate-limit': {\n      response: {\n        status: 429,\n        data: { error: 'Rate limit exceeded', retryAfter: 60 }\n      }\n    }\n  };\n  \n  return errors[type];\n};\n\n// Time-based data generators\nexport const generateTimeSeriesData = (days: number, interval: 'hour' | 'day' = 'hour') => {\n  const points = interval === 'hour' ? days * 24 : days;\n  const intervalMs = interval === 'hour' ? 3600000 : 86400000;\n  const startTime = Date.now() - (days * 86400000);\n  \n  return Array.from({ length: points }, (_, i) => ({\n    timestamp: startTime + (i * intervalMs),\n    value: 1000 + Math.sin(i * 0.1) * 100 + Math.random() * 50,\n    volume: Math.random() * 1000 + 100\n  }));\n};\n\n// Export all mock utilities\nexport default {\n  TEST_CONFIG,\n  MOCK_ADDRESSES,\n  createMockTrader,\n  createMockTraderList,\n  createMockTrade,\n  createMockTradeHistory,\n  createMockPosition,\n  createMockOrderRequest,\n  mockApiResponses,\n  mockWebSocketData,\n  validateTraderStats,\n  validateTrade,\n  createLargeDataset,\n  simulateApiError,\n  generateTimeSeriesData\n};"