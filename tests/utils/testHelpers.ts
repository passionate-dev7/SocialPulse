/**\n * Test helper functions and utilities for SocialPulse testing\n */\n\nimport { render, RenderOptions, RenderResult } from '@testing-library/react';\nimport { ReactElement } from 'react';\nimport { jest } from '@jest/globals';\n\n// Mock providers and contexts\nexport const createMockProvider = (initialState?: any) => {\n  return ({ children }: { children: React.ReactNode }) => {\n    // In a real app, this would wrap with providers like Redux, ThemeProvider, etc.\n    return <div data-testid=\"mock-provider\">{children}</div>;\n  };\n};\n\n// Custom render function with providers\nexport const renderWithProviders = (\n  ui: ReactElement,\n  options?: Omit<RenderOptions, 'wrapper'> & {\n    initialState?: any;\n    store?: any;\n  }\n): RenderResult => {\n  const { initialState, store, ...renderOptions } = options || {};\n  const Wrapper = createMockProvider(initialState);\n  \n  return render(ui, { wrapper: Wrapper, ...renderOptions });\n};\n\n// Async utilities\nexport const waitForElementToBeRemoved = async (\n  element: () => HTMLElement | null,\n  timeout: number = 5000\n): Promise<void> => {\n  return new Promise((resolve, reject) => {\n    const startTime = Date.now();\n    \n    const check = () => {\n      if (!element()) {\n        resolve();\n        return;\n      }\n      \n      if (Date.now() - startTime > timeout) {\n        reject(new Error(`Element was not removed within ${timeout}ms`));\n        return;\n      }\n      \n      setTimeout(check, 100);\n    };\n    \n    check();\n  });\n};\n\n// WebSocket mock utilities\nexport const createMockWebSocket = () => {\n  const mockWs = {\n    readyState: WebSocket.OPEN,\n    send: jest.fn(),\n    close: jest.fn(),\n    onopen: null as ((event: Event) => void) | null,\n    onmessage: null as ((event: MessageEvent) => void) | null,\n    onerror: null as ((event: Event) => void) | null,\n    onclose: null as ((event: CloseEvent) => void) | null,\n    \n    // Test helper methods\n    simulateMessage: (data: any) => {\n      if (mockWs.onmessage) {\n        mockWs.onmessage(new MessageEvent('message', { data: JSON.stringify(data) }));\n      }\n    },\n    \n    simulateOpen: () => {\n      if (mockWs.onopen) {\n        mockWs.onopen(new Event('open'));\n      }\n    },\n    \n    simulateClose: () => {\n      mockWs.readyState = WebSocket.CLOSED;\n      if (mockWs.onclose) {\n        mockWs.onclose(new CloseEvent('close'));\n      }\n    },\n    \n    simulateError: () => {\n      if (mockWs.onerror) {\n        mockWs.onerror(new Event('error'));\n      }\n    }\n  };\n  \n  return mockWs;\n};\n\n// API mock utilities\nexport const createMockApiClient = () => {\n  return {\n    get: jest.fn(),\n    post: jest.fn(),\n    put: jest.fn(),\n    delete: jest.fn(),\n    patch: jest.fn()\n  };\n};\n\n// Performance testing utilities\nexport const measureRenderTime = async (renderFn: () => Promise<void> | void): Promise<number> => {\n  const start = performance.now();\n  await renderFn();\n  return performance.now() - start;\n};\n\nexport const measureMemoryUsage = (): number => {\n  if (typeof window !== 'undefined' && 'performance' in window && 'memory' in window.performance) {\n    return (window.performance as any).memory.usedJSHeapSize;\n  }\n  return 0;\n};\n\n// Form testing utilities\nexport const fillFormFields = async (\n  form: HTMLElement,\n  fields: Record<string, string | number | boolean>\n) => {\n  const { fireEvent } = await import('@testing-library/react');\n  \n  for (const [fieldName, value] of Object.entries(fields)) {\n    const field = form.querySelector(`[name=\"${fieldName}\"]`) as HTMLInputElement;\n    if (!field) continue;\n    \n    if (field.type === 'checkbox' || field.type === 'radio') {\n      if (value) {\n        fireEvent.click(field);\n      }\n    } else {\n      fireEvent.change(field, { target: { value: value.toString() } });\n    }\n  }\n};\n\n// Error boundary for testing error scenarios\nexport class TestErrorBoundary extends React.Component<\n  { children: React.ReactNode; onError?: (error: Error) => void },\n  { hasError: boolean }\n> {\n  constructor(props: any) {\n    super(props);\n    this.state = { hasError: false };\n  }\n  \n  static getDerivedStateFromError(): { hasError: boolean } {\n    return { hasError: true };\n  }\n  \n  componentDidCatch(error: Error) {\n    if (this.props.onError) {\n      this.props.onError(error);\n    }\n  }\n  \n  render() {\n    if (this.state.hasError) {\n      return <div data-testid=\"error-boundary\">Something went wrong.</div>;\n    }\n    \n    return this.props.children;\n  }\n}\n\n// Custom matchers\nexport const customMatchers = {\n  toBeValidTraderAddress: (received: string) => {\n    const isValid = typeof received === 'string' &&\n                   received.length === 42 &&\n                   received.startsWith('0x') &&\n                   /^0x[a-fA-F0-9]{40}$/.test(received);\n    \n    return {\n      message: () => `expected ${received} to be a valid trader address`,\n      pass: isValid\n    };\n  },\n  \n  toBeWithinRange: (received: number, min: number, max: number) => {\n    const pass = received >= min && received <= max;\n    return {\n      message: () => `expected ${received} to be within range ${min}-${max}`,\n      pass\n    };\n  },\n  \n  toHaveValidPnLFormat: (received: string) => {\n    const pass = /^[+-]?\\$[\\d,]+\\.\\d{2}$/.test(received);\n    return {\n      message: () => `expected ${received} to have valid PnL format (e.g., +$1,234.56)`,\n      pass\n    };\n  }\n};\n\n// Test data validation\nexport const validateTestData = {\n  trader: (trader: any) => {\n    const required = ['address', 'pnl', 'volume', 'winRate', 'roi'];\n    const missing = required.filter(field => !(field in trader));\n    if (missing.length > 0) {\n      throw new Error(`Missing required trader fields: ${missing.join(', ')}`);\n    }\n  },\n  \n  trade: (trade: any) => {\n    const required = ['tid', 'coin', 'side', 'px', 'sz', 'time'];\n    const missing = required.filter(field => !(field in trade));\n    if (missing.length > 0) {\n      throw new Error(`Missing required trade fields: ${missing.join(', ')}`);\n    }\n  }\n};\n\n// Mock local storage\nexport const createMockLocalStorage = () => {\n  const storage: Record<string, string> = {};\n  \n  return {\n    getItem: jest.fn((key: string) => storage[key] || null),\n    setItem: jest.fn((key: string, value: string) => {\n      storage[key] = value;\n    }),\n    removeItem: jest.fn((key: string) => {\n      delete storage[key];\n    }),\n    clear: jest.fn(() => {\n      Object.keys(storage).forEach(key => delete storage[key]);\n    }),\n    length: Object.keys(storage).length,\n    key: jest.fn((index: number) => Object.keys(storage)[index] || null)\n  };\n};\n\n// Mock session storage\nexport const createMockSessionStorage = createMockLocalStorage;\n\n// Intersection Observer mock\nexport const createMockIntersectionObserver = () => {\n  const mockObserver = {\n    observe: jest.fn(),\n    unobserve: jest.fn(),\n    disconnect: jest.fn(),\n    \n    // Test helper to simulate intersection\n    simulateIntersection: (entries: any[]) => {\n      // This would be called by the test to simulate intersection\n    }\n  };\n  \n  global.IntersectionObserver = jest.fn().mockImplementation((callback) => {\n    mockObserver.callback = callback;\n    return mockObserver;\n  });\n  \n  return mockObserver;\n};\n\n// Resize Observer mock\nexport const createMockResizeObserver = () => {\n  const mockObserver = {\n    observe: jest.fn(),\n    unobserve: jest.fn(),\n    disconnect: jest.fn()\n  };\n  \n  global.ResizeObserver = jest.fn().mockImplementation(() => mockObserver);\n  \n  return mockObserver;\n};\n\n// Media query mock\nexport const createMockMediaQuery = (matches: boolean = false) => {\n  const mockMediaQuery = {\n    matches,\n    media: '',\n    onchange: null,\n    addListener: jest.fn(),\n    removeListener: jest.fn(),\n    addEventListener: jest.fn(),\n    removeEventListener: jest.fn(),\n    dispatchEvent: jest.fn()\n  };\n  \n  global.matchMedia = jest.fn().mockImplementation(() => mockMediaQuery);\n  \n  return mockMediaQuery;\n};\n\n// Clipboard API mock\nexport const createMockClipboard = () => {\n  const mockClipboard = {\n    writeText: jest.fn().mockResolvedValue(undefined),\n    readText: jest.fn().mockResolvedValue(''),\n    write: jest.fn().mockResolvedValue(undefined),\n    read: jest.fn().mockResolvedValue([]),\n    \n    // Test helper to simulate clipboard content\n    setMockText: (text: string) => {\n      mockClipboard.readText.mockResolvedValue(text);\n    }\n  };\n  \n  Object.defineProperty(navigator, 'clipboard', {\n    value: mockClipboard,\n    writable: true\n  });\n  \n  return mockClipboard;\n};\n\n// URL mock utilities\nexport const mockURL = (url: string) => {\n  const mockUrlObject = {\n    href: url,\n    origin: new URL(url).origin,\n    pathname: new URL(url).pathname,\n    search: new URL(url).search,\n    hash: new URL(url).hash\n  };\n  \n  Object.defineProperty(window, 'location', {\n    value: mockUrlObject,\n    writable: true\n  });\n  \n  return mockUrlObject;\n};\n\n// Console mock utilities (for testing console output)\nexport const createMockConsole = () => {\n  const originalConsole = global.console;\n  const mockConsole = {\n    log: jest.fn(),\n    warn: jest.fn(),\n    error: jest.fn(),\n    info: jest.fn(),\n    debug: jest.fn()\n  };\n  \n  global.console = mockConsole as any;\n  \n  return {\n    mockConsole,\n    restore: () => {\n      global.console = originalConsole;\n    }\n  };\n};\n\n// Async test utilities\nexport const waitForCondition = async (\n  condition: () => boolean,\n  timeout: number = 5000,\n  interval: number = 100\n): Promise<void> => {\n  return new Promise((resolve, reject) => {\n    const startTime = Date.now();\n    \n    const check = () => {\n      if (condition()) {\n        resolve();\n        return;\n      }\n      \n      if (Date.now() - startTime > timeout) {\n        reject(new Error(`Condition not met within ${timeout}ms`));\n        return;\n      }\n      \n      setTimeout(check, interval);\n    };\n    \n    check();\n  });\n};\n\n// Test setup helpers\nexport const setupTestEnvironment = () => {\n  // Mock localStorage\n  const mockLocalStorage = createMockLocalStorage();\n  Object.defineProperty(window, 'localStorage', { value: mockLocalStorage });\n  \n  // Mock sessionStorage\n  const mockSessionStorage = createMockSessionStorage();\n  Object.defineProperty(window, 'sessionStorage', { value: mockSessionStorage });\n  \n  // Mock IntersectionObserver\n  createMockIntersectionObserver();\n  \n  // Mock ResizeObserver\n  createMockResizeObserver();\n  \n  // Mock matchMedia\n  createMockMediaQuery();\n  \n  // Mock clipboard\n  createMockClipboard();\n  \n  // Mock crypto for test environments\n  if (typeof crypto === 'undefined') {\n    const nodeCrypto = require('crypto');\n    Object.defineProperty(global, 'crypto', {\n      value: {\n        getRandomValues: (arr: any) => nodeCrypto.randomBytes(arr.length),\n        randomUUID: () => nodeCrypto.randomUUID()\n      }\n    });\n  }\n  \n  return {\n    localStorage: mockLocalStorage,\n    sessionStorage: mockSessionStorage\n  };\n};\n\n// Cleanup helpers\nexport const cleanupTestEnvironment = () => {\n  jest.clearAllMocks();\n  jest.clearAllTimers();\n  \n  // Reset DOM\n  if (typeof document !== 'undefined') {\n    document.body.innerHTML = '';\n  }\n};\n\nexport default {\n  renderWithProviders,\n  createMockWebSocket,\n  createMockApiClient,\n  measureRenderTime,\n  measureMemoryUsage,\n  fillFormFields,\n  TestErrorBoundary,\n  customMatchers,\n  validateTestData,\n  createMockLocalStorage,\n  createMockSessionStorage,\n  createMockIntersectionObserver,\n  createMockResizeObserver,\n  createMockMediaQuery,\n  createMockClipboard,\n  mockURL,\n  createMockConsole,\n  waitForCondition,\n  setupTestEnvironment,\n  cleanupTestEnvironment\n};"