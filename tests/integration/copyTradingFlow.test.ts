import { HyperliquidClient } from '../../src/services/hyperliquid';
import { TraderStats, Trade } from '../../src/services/hyperliquid';

// Mock external dependencies
jest.mock('axios');
jest.mock('ethers');

// Mock WebSocket
global.WebSocket = jest.fn().mockImplementation(() => ({
  readyState: WebSocket.OPEN,
  send: jest.fn(),
  close: jest.fn(),
  onopen: null,
  onmessage: null,
  onerror: null,
  onclose: null
})) as any;

describe('Copy Trading Flow Integration Tests', () => {
  let client: HyperliquidClient;
  let mockAxios: any;
  let mockWebSocket: any;

  const mockTrader: TraderStats = {
    address: '0x1234567890123456789012345678901234567890',
    pnl: 15420.50,
    volume: 2500000.75,
    winRate: 68.5,
    sharpeRatio: 2.34,
    maxDrawdown: 12.8,
    totalTrades: 156,
    avgHoldTime: 4.2,
    roi: 24.8
  };

  const mockFollowerAddress = '0x9876543210987654321098765432109876543210';

  beforeEach(() => {
    // Setup mocks
    const axios = require('axios');
    mockAxios = {
      post: jest.fn(),
      create: jest.fn().mockReturnThis()
    };
    axios.create.mockReturnValue(mockAxios);

    mockWebSocket = {
      readyState: WebSocket.OPEN,
      send: jest.fn(),
      close: jest.fn(),
      onopen: null,
      onmessage: null,
      onerror: null,
      onclose: null
    };
    (global.WebSocket as any).mockImplementation(() => mockWebSocket);

    // Mock ethers
    const ethers = require('ethers');
    ethers.ethers = {
      Wallet: jest.fn().mockImplementation(() => ({
        address: mockFollowerAddress,
        signMessage: jest.fn().mockResolvedValue('0xsignature123')\n      })),\n      utils: {\n        keccak256: jest.fn().mockReturnValue('0xhash123'),\n        toUtf8Bytes: jest.fn().mockReturnValue(new Uint8Array([1, 2, 3]))\n      }\n    };\n\n    client = new HyperliquidClient({\n      apiUrl: 'https://test-api.hyperliquid.xyz',\n      wsUrl: 'wss://test-api.hyperliquid.xyz/ws',\n      chainId: 1337,\n      privateKey: '0x' + '0'.repeat(64)\n    });\n\n    jest.clearAllMocks();\n  });\n\n  describe('Complete Copy Trading Setup Flow', () => {\n    it('should successfully set up copy trading for a trader', async () => {\n      // Mock API responses for trader discovery\n      const mockLeaderboardResponse = [{\n        ...mockTrader,\n        trades: [\n          { tid: 't1', coin: 'BTC', side: 'buy', px: 47000, sz: 1, time: 1640995200000, fee: 0.05 },\n          { tid: 't2', coin: 'BTC', side: 'sell', px: 48000, sz: 1, time: 1640995300000, fee: 0.05 }\n        ]\n      }];\n\n      const mockAccountInfo = {\n        marginSummary: { accountValue: '10000', totalNtlPos: '2000' },\n        assetPositions: []\n      };\n\n      mockAxios.post\n        .mockResolvedValueOnce({ data: mockLeaderboardResponse }) // getTopTraders\n        .mockResolvedValueOnce({ data: mockAccountInfo }); // getAccountInfo\n\n      // Step 1: Discover top traders\n      const topTraders = await client.getTopTraders(10);\n      expect(topTraders).toHaveLength(1);\n      expect(topTraders[0].address).toBe(mockTrader.address);\n\n      // Step 2: Check follower's account balance\n      const accountInfo = await client.getAccountInfo(mockFollowerAddress);\n      expect(accountInfo.marginSummary.accountValue).toBe('10000');\n\n      // Step 3: Set up follow relationship\n      const followResult = await client.followTrader(mockTrader.address, 25);\n      expect(followResult).toEqual({\n        follower: mockFollowerAddress,\n        trader: mockTrader.address,\n        allocation: 25,\n        status: 'active',\n        timestamp: expect.any(Number)\n      });\n\n      expect(mockAxios.post).toHaveBeenCalledTimes(2);\n    });\n\n    it('should handle insufficient balance scenario', async () => {\n      const mockAccountInfoLowBalance = {\n        marginSummary: { accountValue: '100', totalNtlPos: '90' },\n        assetPositions: []\n      };\n\n      mockAxios.post.mockResolvedValue({ data: mockAccountInfoLowBalance });\n\n      const accountInfo = await client.getAccountInfo(mockFollowerAddress);\n      const availableBalance = parseFloat(accountInfo.marginSummary.accountValue) - \n                              parseFloat(accountInfo.marginSummary.totalNtlPos);\n\n      expect(availableBalance).toBe(10); // Only $10 available\n\n      // Should not allow high allocation with low balance\n      const allocation = 25; // 25%\n      const estimatedPositionSize = availableBalance * (allocation / 100);\n      expect(estimatedPositionSize).toBe(2.5); // Very small position\n\n      // In a real implementation, this would trigger a warning or adjustment\n      expect(estimatedPositionSize).toBeLessThan(100); // Below minimum position threshold\n    });\n  });\n\n  describe('Real-time Trade Copying', () => {\n    it('should copy trades in real-time via WebSocket', async () => {\n      const mockTrade: Trade = {\n        tid: 't123',\n        coin: 'BTC',\n        side: 'buy',\n        px: 47500,\n        sz: 2,\n        time: Date.now(),\n        fee: 0.1\n      };\n\n      const mockOrderResponse = {\n        status: 'ok',\n        response: { type: 'order', data: { statuses: ['success'] } }\n      };\n\n      mockAxios.post.mockResolvedValue({ data: mockOrderResponse });\n\n      // Set up WebSocket connection\n      const onMessage = jest.fn();\n      client.connectWebSocket(onMessage);\n\n      // Subscribe to trader's events\n      client.subscribeToUserEvents(mockTrader.address);\n      expect(mockWebSocket.send).toHaveBeenCalledWith(JSON.stringify({\n        method: 'subscribe',\n        subscription: {\n          type: 'userEvents',\n          user: mockTrader.address\n        }\n      }));\n\n      // Simulate receiving a trade from the followed trader\n      const tradeEvent = {\n        type: 'trade',\n        user: mockTrader.address,\n        data: mockTrade\n      };\n      \n      mockWebSocket.onmessage({ data: JSON.stringify(tradeEvent) });\n      expect(onMessage).toHaveBeenCalledWith(tradeEvent);\n\n      // Copy the trade with 25% allocation\n      const copyResult = await client.copyTrade(mockTrader.address, mockTrade, 25);\n\n      expect(mockAxios.post).toHaveBeenCalledWith('/exchange', expect.objectContaining({\n        action: {\n          type: 'order',\n          orders: [{\n            coin: 'BTC',\n            isBuy: true,\n            sz: 0.5, // 25% of original 2 BTC\n            orderType: 'market',\n            timestamp: expect.any(Number),\n            nonce: expect.any(Number)\n          }]\n        },\n        signature: '0xsignature123',\n        timestamp: expect.any(Number)\n      }));\n\n      expect(copyResult).toEqual(mockOrderResponse);\n    });\n\n    it('should handle WebSocket reconnection during copy trading', () => {\n      jest.useFakeTimers();\n      \n      const onMessage = jest.fn();\n      client.connectWebSocket(onMessage);\n\n      // Simulate connection drop\n      mockWebSocket.onclose();\n\n      // Should attempt reconnection after 5 seconds\n      jest.advanceTimersByTime(5000);\n      expect(global.WebSocket).toHaveBeenCalledTimes(2);\n\n      jest.useRealTimers();\n    });\n\n    it('should apply risk management rules during copy trading', async () => {\n      const largeTrade: Trade = {\n        tid: 't456',\n        coin: 'ETH',\n        side: 'buy',\n        px: 3000,\n        sz: 10, // Large position\n        time: Date.now(),\n        fee: 0.5\n      };\n\n      // Mock account with limited balance\n      const limitedAccountInfo = {\n        marginSummary: { accountValue: '5000', totalNtlPos: '1000' },\n        assetPositions: []\n      };\n      mockAxios.post.mockResolvedValueOnce({ data: limitedAccountInfo });\n\n      const accountInfo = await client.getAccountInfo(mockFollowerAddress);\n      const availableBalance = 4000; // $5000 - $1000\n      const allocation = 25; // 25%\n      const maxAllocation = availableBalance * 0.25; // $1000\n      \n      // Calculate position size based on original trade\n      const originalValue = largeTrade.px * largeTrade.sz; // $30,000\n      const scaledValue = originalValue * (allocation / 100); // $7,500\n      \n      // Should limit to available allocation\n      const actualPositionValue = Math.min(scaledValue, maxAllocation); // $1,000\n      const actualSize = actualPositionValue / largeTrade.px; // ~0.33 ETH\n\n      expect(actualSize).toBeLessThan(largeTrade.sz); // Reduced from original\n      expect(actualPositionValue).toBeLessThanOrEqual(maxAllocation);\n    });\n  });\n\n  describe('Portfolio Management Integration', () => {\n    it('should track copied positions and performance', async () => {\n      const mockPositions = [\n        {\n          coin: 'BTC',\n          szi: 0.5, // Copied position\n          entryPx: 47000,\n          unrealizedPnl: 150,\n          returnOnEquity: 0.15,\n          leverage: 2,\n          maxLeverage: 50,\n          marginUsed: 470\n        },\n        {\n          coin: 'ETH',\n          szi: 2,\n          entryPx: 3000,\n          unrealizedPnl: -50,\n          returnOnEquity: -0.03,\n          leverage: 1.5,\n          maxLeverage: 25,\n          marginUsed: 4000\n        }\n      ];\n\n      const mockTradeHistory: Trade[] = [\n        { tid: 't1', coin: 'BTC', side: 'buy', px: 47000, sz: 0.5, time: Date.now() - 3600000, fee: 0.025 },\n        { tid: 't2', coin: 'ETH', side: 'buy', px: 3000, sz: 2, time: Date.now() - 1800000, fee: 0.1 }\n      ];\n\n      mockAxios.post\n        .mockResolvedValueOnce({ data: { assetPositions: mockPositions } }) // getPositions\n        .mockResolvedValueOnce({ data: mockTradeHistory }); // getTradeHistory\n\n      // Get current positions (including copied trades)\n      const positions = await client.getPositions(mockFollowerAddress);\n      expect(positions).toHaveLength(2);\n      expect(positions[0].coin).toBe('BTC');\n      expect(positions[0].szi).toBe(0.5); // Scaled position\n\n      // Calculate copy trading performance\n      const trades = await client.getTradeHistory(mockFollowerAddress);\n      const totalPnl = positions.reduce((sum, pos) => sum + pos.unrealizedPnl, 0);\n      const totalMarginUsed = positions.reduce((sum, pos) => sum + pos.marginUsed, 0);\n      const copyTradingROI = (totalPnl / totalMarginUsed) * 100;\n\n      expect(totalPnl).toBe(100); // $150 - $50\n      expect(copyTradingROI).toBeCloseTo(2.24); // ~2.24% return\n    });\n\n    it('should handle stop loss execution for copied trades', async () => {\n      const mockPosition = {\n        coin: 'BTC',\n        szi: 1,\n        entryPx: 47000,\n        unrealizedPnl: -2350, // -5% loss\n        returnOnEquity: -0.05,\n        leverage: 1,\n        maxLeverage: 50,\n        marginUsed: 47000\n      };\n\n      const mockCancelResponse = { status: 'ok' };\n      mockAxios.post\n        .mockResolvedValueOnce({ data: { assetPositions: [mockPosition] } })\n        .mockResolvedValueOnce({ data: mockCancelResponse });\n\n      const positions = await client.getPositions(mockFollowerAddress);\n      const btcPosition = positions.find(p => p.coin === 'BTC');\n      \n      // Check if stop loss should trigger (e.g., -5% loss)\n      const stopLossThreshold = -0.05; // -5%\n      if (btcPosition && btcPosition.returnOnEquity <= stopLossThreshold) {\n        // Execute stop loss by closing position\n        const stopLossOrder = {\n          coin: 'BTC',\n          isBuy: false, // Sell to close\n          sz: Math.abs(btcPosition.szi),\n          orderType: 'market' as const\n        };\n\n        const result = await client.placeOrder(stopLossOrder);\n        expect(mockAxios.post).toHaveBeenCalledWith('/exchange', expect.objectContaining({\n          action: {\n            type: 'order',\n            orders: [expect.objectContaining({\n              coin: 'BTC',\n              isBuy: false,\n              sz: 1,\n              orderType: 'market'\n            })]\n          }\n        }));\n      }\n    });\n  });\n\n  describe('Error Handling and Edge Cases', () => {\n    it('should handle API failures gracefully during copy trading', async () => {\n      const mockTrade: Trade = {\n        tid: 't789',\n        coin: 'SOL',\n        side: 'buy',\n        px: 100,\n        sz: 5,\n        time: Date.now(),\n        fee: 0.02\n      };\n\n      // Mock API failure\n      mockAxios.post.mockRejectedValue({\n        response: {\n          status: 500,\n          data: { error: 'Internal server error' }\n        }\n      });\n\n      await expect(\n        client.copyTrade(mockTrader.address, mockTrade, 20)\n      ).rejects.toMatchObject({\n        response: {\n          status: 500,\n          data: { error: 'Internal server error' }\n        }\n      });\n    });\n\n    it('should handle market closure during copy attempts', async () => {\n      const mockTrade: Trade = {\n        tid: 't999',\n        coin: 'BTC',\n        side: 'buy',\n        px: 47000,\n        sz: 1,\n        time: Date.now(),\n        fee: 0.05\n      };\n\n      // Mock market closed error\n      mockAxios.post.mockRejectedValue({\n        response: {\n          status: 400,\n          data: { error: 'Market closed' }\n        }\n      });\n\n      await expect(\n        client.copyTrade(mockTrader.address, mockTrade, 15)\n      ).rejects.toMatchObject({\n        response: {\n          status: 400,\n          data: { error: 'Market closed' }\n        }\n      });\n    });\n\n    it('should handle duplicate trade prevention', async () => {\n      const mockTrade: Trade = {\n        tid: 't555', // Same trade ID\n        coin: 'ETH',\n        side: 'sell',\n        px: 3100,\n        sz: 1,\n        time: Date.now(),\n        fee: 0.08\n      };\n\n      // First copy attempt succeeds\n      mockAxios.post.mockResolvedValueOnce({\n        data: { status: 'ok', response: { type: 'order', data: { statuses: ['success'] } } }\n      });\n\n      const firstResult = await client.copyTrade(mockTrader.address, mockTrade, 30);\n      expect(firstResult.status).toBe('ok');\n\n      // Second copy attempt with same trade ID should be prevented\n      // In a real implementation, this would check against processed trade IDs\n      const processedTradeIds = new Set(['t555']);\n      \n      if (processedTradeIds.has(mockTrade.tid)) {\n        // Skip duplicate trade\n        expect(processedTradeIds.has('t555')).toBe(true);\n      }\n    });\n\n    it('should handle partial fill scenarios', async () => {\n      const mockTrade: Trade = {\n        tid: 't666',\n        coin: 'BTC',\n        side: 'buy',\n        px: 46000,\n        sz: 2,\n        time: Date.now(),\n        fee: 0.1\n      };\n\n      // Mock partial fill response\n      const partialFillResponse = {\n        status: 'ok',\n        response: {\n          type: 'order',\n          data: {\n            statuses: [{\n              filled: 0.3, // Only 30% filled\n              pending: 0.2, // 20% pending\n              cancelled: 0   // None cancelled\n            }]\n          }\n        }\n      };\n\n      mockAxios.post.mockResolvedValue({ data: partialFillResponse });\n\n      const result = await client.copyTrade(mockTrader.address, mockTrade, 25);\n      \n      // Should still return result even with partial fill\n      expect(result.status).toBe('ok');\n      expect(result.response.data.statuses[0].filled).toBe(0.3);\n    });\n  });\n\n  describe('Performance and Scalability', () => {\n    it('should handle multiple simultaneous copy trades efficiently', async () => {\n      const mockTrades: Trade[] = Array.from({ length: 10 }, (_, i) => ({\n        tid: `t${i}`,\n        coin: 'BTC',\n        side: Math.random() > 0.5 ? 'buy' : 'sell',\n        px: 47000 + (Math.random() - 0.5) * 1000,\n        sz: Math.random() * 2,\n        time: Date.now() - i * 1000,\n        fee: 0.05\n      }));\n\n      mockAxios.post.mockResolvedValue({\n        data: { status: 'ok', response: { type: 'order', data: { statuses: ['success'] } } }\n      });\n\n      const startTime = performance.now();\n      \n      // Execute all copy trades in parallel\n      const copyPromises = mockTrades.map(trade => \n        client.copyTrade(mockTrader.address, trade, 10)\n      );\n      \n      const results = await Promise.all(copyPromises);\n      const endTime = performance.now();\n      \n      expect(results).toHaveLength(10);\n      expect(results.every(r => r.status === 'ok')).toBe(true);\n      expect(endTime - startTime).toBeLessThan(5000); // Should complete within 5 seconds\n    });\n\n    it('should batch WebSocket subscriptions for multiple traders', () => {\n      const traderAddresses = [\n        '0x1111111111111111111111111111111111111111',\n        '0x2222222222222222222222222222222222222222',\n        '0x3333333333333333333333333333333333333333'\n      ];\n\n      const onMessage = jest.fn();\n      client.connectWebSocket(onMessage);\n\n      // Subscribe to multiple traders efficiently\n      traderAddresses.forEach(address => {\n        client.subscribeToUserEvents(address);\n      });\n\n      expect(mockWebSocket.send).toHaveBeenCalledTimes(3);\n      \n      // Each subscription should be properly formatted\n      traderAddresses.forEach((address, index) => {\n        expect(mockWebSocket.send).toHaveBeenNthCalledWith(index + 1, JSON.stringify({\n          method: 'subscribe',\n          subscription: {\n            type: 'userEvents',\n            user: address\n          }\n        }));\n      });\n    });\n  });\n});"