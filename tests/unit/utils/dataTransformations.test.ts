/**\n * Unit tests for data transformation utilities\n */\n\nimport {\n  formatCurrency,\n  formatPercentage,\n  formatAddress,\n  formatVolume,\n  formatTimeAgo,\n  calculateMetrics,\n  validateTraderData\n} from '../../../src/utils/formatters';\n\nimport {\n  createMockTrader,\n  createMockTrade,\n  createMockTradeHistory\n} from '../../utils/mockData';\n\ndescribe('Data Transformation Utilities', () => {\n  describe('formatCurrency', () => {\n    it('should format positive currency values correctly', () => {\n      expect(formatCurrency(1234.56)).toBe('$1,234.56');\n      expect(formatCurrency(1234567.89)).toBe('$1,234,567.89');\n      expect(formatCurrency(0.01)).toBe('$0.01');\n    });\n\n    it('should format negative currency values correctly', () => {\n      expect(formatCurrency(-1234.56)).toBe('-$1,234.56');\n      expect(formatCurrency(-0.01)).toBe('-$0.01');\n    });\n\n    it('should handle zero values', () => {\n      expect(formatCurrency(0)).toBe('$0.00');\n      expect(formatCurrency(-0)).toBe('$0.00');\n    });\n\n    it('should handle very large numbers', () => {\n      expect(formatCurrency(1234567890.12)).toBe('$1,234,567,890.12');\n    });\n\n    it('should handle very small numbers', () => {\n      expect(formatCurrency(0.001)).toBe('$0.00'); // Should round to 2 decimals\n      expect(formatCurrency(0.009)).toBe('$0.01'); // Should round up\n    });\n\n    it('should handle undefined and null values', () => {\n      expect(formatCurrency(undefined as any)).toBe('$0.00');\n      expect(formatCurrency(null as any)).toBe('$0.00');\n    });\n  });\n\n  describe('formatPercentage', () => {\n    it('should format percentage values correctly', () => {\n      expect(formatPercentage(25.67)).toBe('25.67%');\n      expect(formatPercentage(0)).toBe('0.00%');\n      expect(formatPercentage(100)).toBe('100.00%');\n    });\n\n    it('should format negative percentages', () => {\n      expect(formatPercentage(-12.34)).toBe('-12.34%');\n    });\n\n    it('should handle decimal precision', () => {\n      expect(formatPercentage(25.123456, 1)).toBe('25.1%');\n      expect(formatPercentage(25.123456, 3)).toBe('25.123%');\n    });\n\n    it('should handle very large percentages', () => {\n      expect(formatPercentage(999.99)).toBe('999.99%');\n    });\n  });\n\n  describe('formatAddress', () => {\n    const longAddress = '0x1234567890123456789012345678901234567890';\n\n    it('should truncate long addresses correctly', () => {\n      expect(formatAddress(longAddress)).toBe('0x1234...7890');\n    });\n\n    it('should handle short addresses', () => {\n      const shortAddress = '0x1234';\n      expect(formatAddress(shortAddress)).toBe('0x1234');\n    });\n\n    it('should handle custom truncation lengths', () => {\n      expect(formatAddress(longAddress, 6)).toBe('0x123456...567890');\n      expect(formatAddress(longAddress, 8)).toBe('0x12345678...12345678');\n    });\n\n    it('should handle invalid addresses gracefully', () => {\n      expect(formatAddress('')).toBe('');\n      expect(formatAddress(null as any)).toBe('');\n      expect(formatAddress(undefined as any)).toBe('');\n    });\n  });\n\n  describe('formatVolume', () => {\n    it('should format large volumes with appropriate suffixes', () => {\n      expect(formatVolume(1500)).toBe('$1.5K');\n      expect(formatVolume(2500000)).toBe('$2.5M');\n      expect(formatVolume(3500000000)).toBe('$3.5B');\n      expect(formatVolume(4500000000000)).toBe('$4.5T');\n    });\n\n    it('should format small volumes without suffixes', () => {\n      expect(formatVolume(999)).toBe('$999.00');\n      expect(formatVolume(100)).toBe('$100.00');\n    });\n\n    it('should handle edge cases around thresholds', () => {\n      expect(formatVolume(1000)).toBe('$1.0K');\n      expect(formatVolume(999.99)).toBe('$999.99');\n      expect(formatVolume(1000000)).toBe('$1.0M');\n    });\n\n    it('should maintain precision for formatted values', () => {\n      expect(formatVolume(1234567)).toBe('$1.2M');\n      expect(formatVolume(1567890)).toBe('$1.6M');\n    });\n  });\n\n  describe('formatTimeAgo', () => {\n    const now = Date.now();\n    const minute = 60 * 1000;\n    const hour = 60 * minute;\n    const day = 24 * hour;\n    const week = 7 * day;\n    const month = 30 * day;\n    const year = 365 * day;\n\n    beforeEach(() => {\n      jest.spyOn(Date, 'now').mockReturnValue(now);\n    });\n\n    afterEach(() => {\n      jest.restoreAllMocks();\n    });\n\n    it('should format recent times correctly', () => {\n      expect(formatTimeAgo(now - 30000)).toBe('30 seconds ago'); // 30 seconds\n      expect(formatTimeAgo(now - 2 * minute)).toBe('2 minutes ago');\n      expect(formatTimeAgo(now - 3 * hour)).toBe('3 hours ago');\n    });\n\n    it('should format longer periods correctly', () => {\n      expect(formatTimeAgo(now - 2 * day)).toBe('2 days ago');\n      expect(formatTimeAgo(now - 3 * week)).toBe('3 weeks ago');\n      expect(formatTimeAgo(now - 4 * month)).toBe('4 months ago');\n      expect(formatTimeAgo(now - 2 * year)).toBe('2 years ago');\n    });\n\n    it('should handle singular forms', () => {\n      expect(formatTimeAgo(now - minute)).toBe('1 minute ago');\n      expect(formatTimeAgo(now - hour)).toBe('1 hour ago');\n      expect(formatTimeAgo(now - day)).toBe('1 day ago');\n    });\n\n    it('should handle future timestamps', () => {\n      expect(formatTimeAgo(now + hour)).toBe('just now');\n    });\n\n    it('should handle very recent timestamps', () => {\n      expect(formatTimeAgo(now - 5000)).toBe('just now'); // 5 seconds\n    });\n  });\n\n  describe('calculateMetrics', () => {\n    const mockTrades = [\n      createMockTrade({ side: 'buy', px: 100, sz: 1, time: now - 3600000 }),\n      createMockTrade({ side: 'sell', px: 110, sz: 1, time: now - 1800000 }),\n      createMockTrade({ side: 'buy', px: 105, sz: 2, time: now - 900000 }),\n      createMockTrade({ side: 'sell', px: 115, sz: 1, time: now - 300000 })\n    ];\n\n    it('should calculate basic trading metrics correctly', () => {\n      const metrics = calculateMetrics(mockTrades);\n      \n      expect(metrics.totalTrades).toBe(4);\n      expect(metrics.totalVolume).toBeCloseTo(440); // 100 + 110 + 210 + 115\n      expect(typeof metrics.avgPrice).toBe('number');\n      expect(metrics.avgPrice).toBeGreaterThan(0);\n    });\n\n    it('should calculate PnL correctly', () => {\n      const metrics = calculateMetrics(mockTrades);\n      \n      // Should calculate unrealized PnL based on position changes\n      expect(typeof metrics.pnl).toBe('number');\n      expect(metrics.pnl).toBeCloseTo(25); // (110-100) + (115-105)\n    });\n\n    it('should calculate win rate correctly', () => {\n      const profitableTrades = mockTrades.filter(trade => {\n        // Simplified: assume sell trades at higher price are profitable\n        return trade.side === 'sell' && trade.px > 105;\n      });\n      \n      const metrics = calculateMetrics(mockTrades);\n      const expectedWinRate = (profitableTrades.length / mockTrades.length) * 100;\n      \n      expect(metrics.winRate).toBeCloseTo(expectedWinRate, 1);\n    });\n\n    it('should handle empty trade arrays', () => {\n      const metrics = calculateMetrics([]);\n      \n      expect(metrics.totalTrades).toBe(0);\n      expect(metrics.totalVolume).toBe(0);\n      expect(metrics.pnl).toBe(0);\n      expect(metrics.winRate).toBe(0);\n      expect(metrics.avgPrice).toBe(0);\n    });\n\n    it('should calculate time-based metrics', () => {\n      const metrics = calculateMetrics(mockTrades);\n      \n      expect(typeof metrics.avgHoldTime).toBe('number');\n      expect(metrics.avgHoldTime).toBeGreaterThanOrEqual(0);\n      \n      // Should calculate trading frequency\n      expect(typeof metrics.tradingFrequency).toBe('number');\n      expect(metrics.tradingFrequency).toBeGreaterThan(0);\n    });\n  });\n\n  describe('validateTraderData', () => {\n    it('should validate complete trader data', () => {\n      const validTrader = createMockTrader();\n      const result = validateTraderData(validTrader);\n      \n      expect(result.isValid).toBe(true);\n      expect(result.errors).toEqual([]);\n    });\n\n    it('should detect missing required fields', () => {\n      const incompleteTrader = {\n        address: '0x1234567890123456789012345678901234567890',\n        // Missing other required fields\n      };\n      \n      const result = validateTraderData(incompleteTrader as any);\n      \n      expect(result.isValid).toBe(false);\n      expect(result.errors).toContain('Missing required field: pnl');\n      expect(result.errors).toContain('Missing required field: volume');\n      expect(result.errors).toContain('Missing required field: winRate');\n    });\n\n    it('should validate address format', () => {\n      const traderWithInvalidAddress = createMockTrader({\n        address: 'invalid-address'\n      });\n      \n      const result = validateTraderData(traderWithInvalidAddress);\n      \n      expect(result.isValid).toBe(false);\n      expect(result.errors).toContain('Invalid address format');\n    });\n\n    it('should validate numeric ranges', () => {\n      const traderWithInvalidData = createMockTrader({\n        winRate: 150, // Invalid: > 100%\n        maxDrawdown: -10, // Invalid: negative\n        totalTrades: -5 // Invalid: negative\n      });\n      \n      const result = validateTraderData(traderWithInvalidData);\n      \n      expect(result.isValid).toBe(false);\n      expect(result.errors).toContain('Win rate must be between 0 and 100');\n      expect(result.errors).toContain('Max drawdown cannot be negative');\n      expect(result.errors).toContain('Total trades cannot be negative');\n    });\n\n    it('should validate data types', () => {\n      const traderWithWrongTypes = {\n        address: '0x1234567890123456789012345678901234567890',\n        pnl: '15420.50', // Should be number\n        volume: '2500000', // Should be number\n        winRate: 'high', // Should be number\n        sharpeRatio: null,\n        maxDrawdown: undefined,\n        totalTrades: 156,\n        avgHoldTime: 4.2,\n        roi: 24.8\n      };\n      \n      const result = validateTraderData(traderWithWrongTypes as any);\n      \n      expect(result.isValid).toBe(false);\n      expect(result.errors).toContain('PnL must be a number');\n      expect(result.errors).toContain('Volume must be a number');\n      expect(result.errors).toContain('Win rate must be a number');\n    });\n\n    it('should validate logical consistency', () => {\n      const inconsistentTrader = createMockTrader({\n        totalTrades: 0,\n        winRate: 75 // Can't have win rate with 0 trades\n      });\n      \n      const result = validateTraderData(inconsistentTrader);\n      \n      expect(result.isValid).toBe(false);\n      expect(result.errors).toContain('Cannot have win rate with zero trades');\n    });\n  });\n\n  describe('Complex Data Transformations', () => {\n    it('should transform raw API data to display format', () => {\n      const rawApiData = {\n        user: '0x1234567890123456789012345678901234567890',\n        accountValue: '125000.123456',\n        totalPnl: '-2345.6789',\n        positions: [\n          {\n            asset: 'BTC',\n            size: '1.23456789',\n            entryPrice: '47123.456789',\n            currentPrice: '48234.567890'\n          }\n        ]\n      };\n      \n      const transformed = transformApiData(rawApiData);\n      \n      expect(transformed.address).toBe('0x1234...7890');\n      expect(transformed.accountValue).toBe('$125,000.12');\n      expect(transformed.totalPnl).toBe('-$2,345.68');\n      expect(transformed.positions[0].size).toBe('1.235'); // Rounded to 3 decimals\n      expect(transformed.positions[0].entryPrice).toBe('$47,123.46');\n    });\n\n    it('should handle batch data transformations efficiently', () => {\n      const largeMockDataset = Array.from({ length: 1000 }, (_, i) => \n        createMockTrader({ address: `0x${i.toString().padStart(40, '0')}` })\n      );\n      \n      const startTime = performance.now();\n      const transformed = largeMockDataset.map(trader => ({\n        displayAddress: formatAddress(trader.address),\n        displayPnl: formatCurrency(trader.pnl),\n        displayRoi: formatPercentage(trader.roi),\n        displayVolume: formatVolume(trader.volume)\n      }));\n      const endTime = performance.now();\n      \n      expect(transformed).toHaveLength(1000);\n      expect(endTime - startTime).toBeLessThan(100); // Should complete within 100ms\n      \n      // Verify first few transformations\n      expect(transformed[0].displayAddress).toBe('0x0000...0000');\n      expect(transformed[0].displayPnl).toMatch(/^[+-]?\\$[\\d,]+\\.\\d{2}$/);\n    });\n\n    it('should preserve data integrity during transformations', () => {\n      const originalTrader = createMockTrader();\n      const transformedForDisplay = {\n        address: formatAddress(originalTrader.address),\n        pnl: formatCurrency(originalTrader.pnl),\n        roi: formatPercentage(originalTrader.roi)\n      };\n      \n      // Original data should remain unchanged\n      expect(originalTrader.address).toHaveLength(42);\n      expect(typeof originalTrader.pnl).toBe('number');\n      expect(typeof originalTrader.roi).toBe('number');\n      \n      // Transformed data should be formatted strings\n      expect(transformedForDisplay.address).toHaveLength(11); // '0x1234...7890'\n      expect(transformedForDisplay.pnl).toMatch(/^[+-]?\\$/);\n      expect(transformedForDisplay.roi).toMatch(/%$/);\n    });\n  });\n\n  describe('Edge Cases and Error Handling', () => {\n    it('should handle extreme numeric values', () => {\n      expect(formatCurrency(Number.MAX_SAFE_INTEGER)).toBeDefined();\n      expect(formatCurrency(Number.MIN_SAFE_INTEGER)).toBeDefined();\n      expect(formatPercentage(Number.MAX_SAFE_INTEGER)).toBeDefined();\n    });\n\n    it('should handle NaN and Infinity values', () => {\n      expect(formatCurrency(NaN)).toBe('$0.00');\n      expect(formatCurrency(Infinity)).toBe('$0.00');\n      expect(formatCurrency(-Infinity)).toBe('$0.00');\n      \n      expect(formatPercentage(NaN)).toBe('0.00%');\n      expect(formatPercentage(Infinity)).toBe('0.00%');\n    });\n\n    it('should handle malformed data gracefully', () => {\n      const malformedData = {\n        address: 123, // Wrong type\n        pnl: 'invalid', // Wrong type\n        volume: { invalid: 'object' }, // Wrong type\n        winRate: [1, 2, 3] // Wrong type\n      };\n      \n      expect(() => validateTraderData(malformedData as any)).not.toThrow();\n      \n      const result = validateTraderData(malformedData as any);\n      expect(result.isValid).toBe(false);\n      expect(result.errors.length).toBeGreaterThan(0);\n    });\n\n    it('should handle concurrent transformations safely', async () => {\n      const traders = Array.from({ length: 100 }, () => createMockTrader());\n      \n      const transformationPromises = traders.map(async trader => {\n        await new Promise(resolve => setTimeout(resolve, Math.random() * 10));\n        return {\n          address: formatAddress(trader.address),\n          pnl: formatCurrency(trader.pnl),\n          roi: formatPercentage(trader.roi)\n        };\n      });\n      \n      const results = await Promise.all(transformationPromises);\n      \n      expect(results).toHaveLength(100);\n      results.forEach(result => {\n        expect(result.address).toMatch(/^0x[a-fA-F0-9]{4}\\.\\.\\.[a-fA-F0-9]{4}$/);\n        expect(result.pnl).toMatch(/^[+-]?\\$[\\d,]+\\.\\d{2}$/);\n        expect(result.roi).toMatch(/^[+-]?\\d+\\.\\d{2}%$/);\n      });\n    });\n  });\n});\n\n// Helper function for API data transformation (would be in actual utils)\nfunction transformApiData(rawData: any) {\n  return {\n    address: formatAddress(rawData.user),\n    accountValue: formatCurrency(parseFloat(rawData.accountValue)),\n    totalPnl: formatCurrency(parseFloat(rawData.totalPnl)),\n    positions: rawData.positions.map((pos: any) => ({\n      asset: pos.asset,\n      size: parseFloat(pos.size).toFixed(3),\n      entryPrice: formatCurrency(parseFloat(pos.entryPrice)),\n      currentPrice: formatCurrency(parseFloat(pos.currentPrice))\n    }))\n  };\n}"